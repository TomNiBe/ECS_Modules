# ECS Module

This repository provides a modern C++20 entity component system (ECS) implementation aimed at high‑performance game engines.  It exposes a small API for issuing commands from your game engine (client or server) and polling events from the ECS.  It also supports loading archetype, weapon and projectile definitions from Lua files and includes a simple example application demonstrating usage.

## Features

- **Data‑oriented design** – Entities are simple IDs managed by a free‑list with generation counters, and components are stored contiguously per type following a structure‑of‑arrays (SoA) layout.  This design improves CPU cache utilisation and provides fast iteration in tight loops【469905400562533†L18-L66】.
- **Sparse‑set mapping** – Each component type maintains a dense array of component data and a sparse mapping from entity IDs to indices.  This allows O(1) add/remove operations and avoids pointer chasing【321621412307981†L212-L237】.
- **Deterministic simulation** – Systems run with a fixed time step.  Structural changes are buffered through a command queue and applied before each update, keeping iterators valid and improving determinism【321621412307981†L212-L258】.
- **Command and event queues** – The `World` class exposes `enqueueCommand` and `pollEvent` methods.  Commands such as spawning entities, destroying entities, changing player direction, equipping weapons or freezing/unfreezing movable entities can be sent from the main thread.  Events such as entity spawned/destroyed or projectile fired are generated by the ECS and can be polled by the engine.
- **Lua configuration** – Archetypes, weapons and projectiles are defined in an external Lua script.  The loader uses the C‑API functions `lua_getfield` and `lua_rawgeti` to traverse tables【450310690924291†L2387-L2391】【450310690924291†L3137-L3142】.
- **Example application** – An executable demonstrates loading the Lua configuration, spawning a player and archers, running the update loop, handling commands, and printing events.

## Using as a git submodule

To add this ECS module to your own game engine, run:

```bash
git submodule add <URL_OF_THIS_REPOSITORY> external/ecs_module
```

Then in your `CMakeLists.txt`:

```cmake
add_subdirectory(external/ecs_module)
target_link_libraries(your_target PRIVATE ecs_core)
```

The static library target `ecs_core` contains the ECS implementation.  The example executable in `src/main.cpp` shows basic usage.

## Building

This project uses CMake.  Ensure Lua 5.3 or Lua 5.4 development headers and library are installed on your system.  On Linux you can usually install them via your package manager (for example `liblua5.3-dev`).  Then build with:

```bash
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build .
```

The example can be run with:

```bash
./ecs_example ../config/example_config.lua
```

## Notes

- The ECS is minimalistic but structured so you can extend it with more systems (e.g., collision or rendering).  The SoA layout for `Transform` and `Movement` components is explicit, while other components use dense arrays for simplicity.
- All hot loops avoid dynamic allocations.  Commands and events are buffered and processed outside of inner loops.